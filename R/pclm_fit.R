
#' Fit PCLM Models
#' 
#' This is an internal function used to estimate PCLM model. It is used by 
#' \code{\link{pclm}} and \code{\link{pclm2D}} functions
#' @inheritParams pclm
#' @inheritParams pclm.control
#' @param pclm.type Type of PCLM model. Options: \code{"1D", "2D"} for 
#' univariate and two-dimensional model respectively.
#' @keywords internal
pclm.fit <- function(x, y, nlast, offset, out.step, show,
                     lambda, kr, deg, diff, max.iter, tol, pclm.type){
  if (show) {pb = startpb(0, 100); setpb(pb, 50); cat("   Ungrouping data      ")}
  # Some preparations
  CM  <- build_C_matrix(x, y, nlast, offset, out.step, pclm.type)
  BM  <- build_B_spline_basis(CM$gx, CM$gy, kr, deg, diff, lambda, pclm.type)
  C   <- CM$C
  B   <- BM$B
  y_  <- as.vector(unlist(y))
  ny_ <- length(y_)
  
  # Perform the iterations
  eta <- B %*% rep(log(sum(y_) / ny_), times = ncol(B))
  mu  <- exp(eta)
  
  for (it in 1:max.iter) {
    mu0  <- mu
    muA  <- c(C %*% mu)  # mu aggregated
    z    <- (y_ - muA) + C %*% (mu * log(mu))
    W    <- C * ((1/muA) %*% t(mu))
    Q    <- t(W %*% B) # This is the slow line that slows down the algorithm
    Qz   <- Q %*% z
    QmQ  <- Q %*% (muA * t(Q))
    QmQP <- QmQ + BM$P
    eta  <- B %*% solve(QmQP, Qz)
    mu   <- exp(eta)
    da   <- max(abs(mu - mu0)/abs(mu))
    if (show) setpb(pb, min(50 + it, 97))
    if (da < tol && it >= 4) break
  }
  if (it == max.iter) {
    warning("The maximal number of iteration has been reached. ",
            "Maybe it is a good idea to increase 'max.iter'. ", call. = F)
  }
  # Regression diagnostics
  H     <- solve(QmQP, QmQ)
  trace <- sum(diag(H))
  y_[y_ == 0] <- 10^-4
  dev   <- 2 * sum(y_ * log(y_ / muA), na.rm = TRUE)
  AIC   <- dev + 2 * trace
  BIC   <- dev + log(ny_) * trace
  fit   <- as.numeric(mu)
  out   <- as.list(environment())
  if (show) {setpb(pb, 98); cat("                       ")}
  return(out)
}

#' Compute Standard Errors and Confidence Intervals
#' @param X An object generated by pclm.fit
#' @inheritParams pclm
#' @keywords internal
pclm.confidence <- function(X, ci.level, pclm.type) {
  with(X, {
    H0    <- solve(QmQP)       # vcov matrix Bayesian approach
    H1    <- H0 %*% QmQ %*% H0 # vcov matrix sandwich estimator
    s.e.  <- sqrt(diag(B %*% H1 %*% t(B)))
    psi2  <- dev / (ny_ - trace) # overdispersion
    # Confidence intervals
    qn    <- qnorm(1 - ci.level/2)
    lower <- as.numeric(exp(eta - qn*s.e.))
    upper <- as.numeric(exp(eta + qn*s.e.))
    
    if (pclm.type == "2D") {
      ny    <- ncol(y)
      fit   <- matrix(fit, ncol = ny)
      upper <- matrix(upper, ncol = ny)
      lower <- matrix(lower, ncol = ny)
      s.e.  <- matrix(s.e., ncol = ny)
    }
    #output
    out <- list(fit = fit, lower = lower, upper = upper, s.e. = s.e.)
    return(out)
  })
}


#' Build Composition Matrices
#' @inheritParams pclm.fit
#' @keywords internal
build_C_matrix <- function(x, y, nlast, offset, out.step, pclm.type) {
  # Build C matrix in the age direction
  nx <- length(x)
  gx <- seq(min(x), max(x) + nlast - out.step, by = out.step)
  gu <- c(diff(x), nlast)/out.step
  CA <- matrix(0, nrow = nx, ncol = sum(gu), dimnames = list(x, gx))
  xr <- c(x[-1], max(x) + nlast)
  for (j in 1:nx) CA[j, which(gx >= x[j] & gx < xr[j])] <- 1
  
  # Build C matrix in the year direction
  if (pclm.type == "1D") {
    ny <- length(y)
    CY <- NULL
    C  <- CA
  } else {
    ny <- ncol(y)
    CY <- diag(1, ncol = ny, nrow = ny) 
    C  <- CY %x% CA # Kronecker product
  }
  gy <- 1:ny
  if (!is.null(offset)) C <- C %*% diag(as.vector(unlist(offset)))
  
  # Output
  out <- as.list(environment())
  return(out)
}


#' Construct B-spline basis
#' This is an internal function which constructs B-spline basis to be used in 
#' pclm estimation
#' @param X vector with ages
#' @param Y vector with years
#' @inheritParams pclm.fit
#' @seealso \code{\link{MortSmooth_bbase}}
#' @keywords internal
build_B_spline_basis <- function(X, Y, kr, deg, diff, lambda, pclm.type) {
  # B-spline basis for age
  nX   <- trunc(length(X)/kr)
  xl   <- min(X)
  xr   <- max(X)
  xmax <- xr + 0.01 * (xr - xl)
  xmin <- xl - 0.01 * (xr - xl)
  BX   <- MortSmooth_bbase(x = X, xmin, xmax, nX, deg) 
  cX   <- ncol(BX)
  dX   <- diag(cX)
  DX   <- diff(dX, diff = diff)
  tDX  <- t(DX) %*% DX
  # mX   <- matrix(1, ncol = cX, nrow = 1)
  # kBX  <- (mX %x% BX) * (BX %x% mX) # tensors product of B-splines
  
  # B-spline basis for year
  nY   <- trunc(length(Y)/kr)
  yl   <- min(Y)
  yr   <- max(Y)
  ymax <- yr + 0.01 * (yr - yl)
  ymin <- yl - 0.01 * (yr - yl)
  BY   <- MortSmooth_bbase(x = Y, ymin, ymax, nY, deg)
  cY   <- ncol(BY)
  dY   <- diag(cY)
  DY   <- diff(dY, diff = diff)
  tDY  <- t(DY) %*% DY
  # mY   <- matrix(1, ncol = cY, nrow = 1)
  # kBY  <- (mY %x% BY) * (BY %x% mY)
  
  # Penalties
  if (pclm.type == "1D") {
    B <- BX 
    P <- lambda * tDX
  } else {
    B  <- BY %x% BX
    Px <- dY %x% tDX
    Py <- tDY %x% dX
    P  <- lambda * (Px + Py) 
  } 
  # output
  out <- as.list(environment())
  return(out)
} 


#' Create an additional bin with a small value at the end. 
#' Improves convergence.
#' @param i A list of input values corresponding to pclm or pclm2D
#' @param vy Numerical value of the bin created for 'y' input
#' @param vo Numerical values of the bin created for 'offset' input (if the case)
#' @keywords internal
create.artificial.bin <- function(i, vy = 1, vo = 1.01){
  with(i, {
    x     <- c(x, max(x) + nlast)
    nlast <- out.step
    L     <- !is.null(offset)
    
    if (is.vector(y)) {
      y <- c(y, vy)
      if (L) offset <- c(offset, vo)
    } else {
      y <- rbind(y, vy)
      if (L) offset <- rbind(offset, vo)
    }
    
    out  <- list(x = x, y = y, nlast = nlast, offset = offset)
    return(out)
  })
}


#' Delete from results the last group added artificially in pclm and pclm2D 
#' @param M A pclm.default object
#' @keywords internal
delete.artificial.bin <- function(M){
  n <- 1
  N <- 1:n
  
  f1 <- function(x) { # method 1 - delete groups and reallocate values
    A <- rev(rev(x)[-N])
    B <- sum(rev(x)[N] - n)
    B * (A/sum(A)) + A
  }
  f2 <- function(x) { # method 2 - delete groups
    rev(rev(x)[-N])
  }
  L = M$pclm.type == "1D"
  M$fit   <- with(M, if (L) f1(fit)   else apply(fit, 2, FUN = f1))
  M$lower <- with(M, if (L) f1(lower) else apply(lower, 2, FUN = f1))
  M$upper <- with(M, if (L) f1(upper) else apply(upper, 2, FUN = f1))
  M$s.e.  <- with(M, if (L) f1(s.e.)  else apply(s.e., 2, FUN = f2))
  return(M)
}


#' Map groups and borders
#' 
#' We assume no missing values between the bins
#' @inheritParams pclm
#' @keywords internal
map.bins <- function(x, nlast, out.step) {
  step  <- c(diff(x), nlast)
  xl    <- rev(rev(c(0, cumsum(step)))[-1]) + 1
  xr    <- xl + step - 1
  N     <- length(xl)
  delta <- x[1] - xl[1]
  bl    <- round(xl + delta, 3)
  br    <- c(bl[-1], xr[N] + 1 + delta)
  
  dnames <- list(c("left", "right"), rep("", N))
  breaks <- matrix(c(bl, br), nrow = 2, byrow = T, dimnames = dnames)
  loc    <- matrix(c(xl, xr), nrow = 2, byrow = T, dimnames = dnames)
  input  <- list(n = N, 
                 length = xr - xl + 1, 
                 names  = paste0("[", bl,",", br, ")"), 
                 breaks = breaks, 
                 location = loc)
  output <- NULL
  if (!is.null(out.step)) {
    X <- range(breaks)
    X <- seqlast(X[1], X[2], by = out.step)
    output <- map.bins(X, NULL, NULL)$input
  }
  
  out <- list(input = input, output = output)
  return(out)
}


#' Sequence function with last value
#' 
#' @inheritParams base::seq
#' @keywords internal 
seqlast <- function(from, to, by) 
{
  vec <- do.call(what = seq, args = list(from, to, by))
  if ( tail(vec, 1) != to ) {
    return(c(vec, to))
  } else {
    return(vec)
  }
}


#' Extract Fractional Part of a Number
#' @param x A numeric value, vector or matrix
#' @keywords internal
frac <- function(x) {
  x - trunc(x)
}


#' Check if 'nlast' needs to be adjusted in order to accommodate out.step
#' @inheritParams pclm
#' @keywords internal
validate.nlast <- function(x, nlast, out.step) {
  len <- max(x) - min(x) + nlast
  N   <- len/out.step
  if (frac(N) != 0) {
    n.bins <- round(N, 0)
    new.nlast <- n.bins * out.step - len + nlast
    vos <- suggest.valid.out.step(len)
    warning("'nlast' has been adjusted in order to obtain ", n.bins, 
            " bins of equal length as specified in 'out.step = ", out.step,
            "'. Now 'nlast = ", new.nlast, "'. The impact in results is insignificant.",
            " However, if the adjustment is not acceptable",
            " try out one of the following 'out.step' values: ", 
            paste(vos, collapse = ", "), ".", call. = F)
  } else {
    new.nlast <- nlast
  }
  return(new.nlast)
}

#' Suggest values of 'out.step' that do not require an adjustment of 'nlast'
#' @param len Interval length
#' @param increment Increment
#' @keywords internal
suggest.valid.out.step <- function(len, increment = 0.01) {
  o  <- seq(0.1, 1, by = increment)
  v  <- len/o
  tv <- trunc(v)
  o[v == tv]
}



